<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WFM Productivity Dashboard</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        /* Dark Mode Styles */
        body { 
            font-family: 'Inter', sans-serif; 
            background-color: #111827; /* Dark Gray 900 */
            color: #f3f4f6; /* Gray 100 */
        } 
        /* Custom scrollbar for better look in dark mode */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1f2937; } /* Gray 800 */
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; } /* Gray 600 */
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; } /* Gray 500 */
        .log-entry:hover .delete-btn { opacity: 1; }
    </style>
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, orderBy, addDoc, serverTimestamp, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global Firebase variables for easy access in the main script
        window.firebase = {
            initializeApp, getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged,
            getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, orderBy, addDoc, serverTimestamp, getDocs, setLogLevel
        };
    </script>
</head>
<body class="min-h-screen flex flex-col antialiased">

    <!-- Header: Timer & Controls (Fixed Top Right) -->
    <header id="header" class="fixed top-0 right-0 p-4 z-40 w-full sm:w-auto transition-all duration-300">
        <div id="timer-display-container" class="hidden bg-gray-800 shadow-xl rounded-lg p-3 flex items-center space-x-3 border border-indigo-900">
            <span class="text-xs font-semibold text-indigo-400 uppercase">Remaining:</span>
            <span id="timer-display" class="text-3xl font-bold text-indigo-300">00:00:00</span>
        </div>
        <button id="toggle-log-btn" onclick="toggleView()" class="hidden mt-2 px-3 py-1 bg-indigo-500 text-white text-sm font-medium rounded-full shadow-md hover:bg-indigo-600 transition duration-150">View Log</button>
    </header>

    <!-- Main Content Area -->
    <main class="flex-grow p-4 sm:p-8 pt-20">

        <!-- Initial Setup Modal (Large Button Pop-up) -->
        <div id="setup-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50">
            <div class="bg-gray-800 p-8 rounded-xl shadow-2xl w-full max-w-lg mx-4">
                <h2 class="text-2xl font-bold mb-6 text-indigo-400">Start Your Workday</h2>
                <div class="mb-6">
                    <label for="work-hours" class="block text-sm font-medium text-gray-100 mb-2">How many hours will you be working today?</label>
                    <input type="number" id="work-hours" min="1" max="12" value="8" class="w-full p-3 border border-gray-600 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 text-lg bg-gray-700 text-white">
                </div>
                <button id="start-work-btn" onclick="startWorkday()" class="w-full p-4 text-xl font-bold bg-indigo-600 text-white rounded-xl hover:bg-indigo-700 transition shadow-lg shadow-indigo-800/50">
                    START WORK DAY
                </button>
            </div>
        </div>

        <!-- Task Dashboard View -->
        <div id="dashboard-view" class="max-w-4xl mx-auto space-y-8 hidden">
            <!-- Workday Controls -->
            <section class="bg-gray-800 p-6 rounded-xl shadow-lg border border-gray-700">
                <h3 class="text-xl font-semibold text-gray-100 mb-4">Timer Controls</h3>
                <div class="flex flex-wrap gap-3">
                    <button onclick="pauseTimer(15)" class="px-4 py-2 bg-yellow-900/40 text-yellow-300 rounded-lg font-medium hover:bg-yellow-800/40 transition">Pause +15 mins</button>
                    <button onclick="pauseTimer(30)" class="px-4 py-2 bg-yellow-900/40 text-yellow-300 rounded-lg font-medium hover:bg-yellow-800/40 transition">Pause +30 mins</button>
                    <button onclick="pauseTimer(60)" class="px-4 py-2 bg-yellow-900/40 text-yellow-300 rounded-lg font-medium hover:bg-yellow-800/40 transition">Pause +1 hour</button>
                    <button id="reset-work-btn" onclick="confirmReset()" class="px-4 py-2 bg-red-900/40 text-red-300 rounded-lg font-medium hover:bg-red-800/40 transition">End Workday</button>
                </div>
            </section>

            <!-- Task Input -->
            <section class="bg-gray-800 p-6 rounded-xl shadow-lg border border-gray-700">
                <h3 class="text-xl font-semibold text-gray-100 mb-4">What would you like to accomplish today?</h3>
                <div class="flex space-x-3">
                    <input type="text" id="new-task-input" placeholder="Enter a new task..." class="flex-grow p-3 border border-gray-600 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 bg-gray-700 text-white">
                    <button onclick="addTask()" class="px-6 py-3 bg-indigo-600 text-white rounded-lg font-bold hover:bg-indigo-700 transition shadow-md">Add</button>
                </div>
            </section>

            <!-- Task List -->
            <section class="bg-gray-800 p-6 rounded-xl shadow-lg border border-gray-700 min-h-[200px]">
                <h3 class="text-xl font-semibold text-gray-100 mb-4">To Do List</h3>
                <ul id="task-list" class="space-y-3">
                    <!-- Tasks will be injected here -->
                    <p id="tasks-empty-state" class="text-gray-400 italic">No tasks yet. Add one above!</p>
                </ul>
            </section>
        </div>

        <!-- Activity Log View -->
        <div id="log-view" class="max-w-4xl mx-auto space-y-8 hidden">
            <h2 class="text-3xl font-bold text-indigo-400">Workday Activity Log</h2>
            <p class="text-gray-300">Review your 30-minute check-ins throughout the day.</p>
            <div id="log-entries-container" class="space-y-4">
                <!-- Log entries will be injected here -->
                <p id="log-empty-state" class="text-gray-400 italic p-4 bg-gray-800 rounded-lg shadow">No check-in entries yet.</p>
            </div>
            <button onclick="toggleView()" class="px-4 py-2 bg-indigo-500 text-white rounded-lg font-medium hover:bg-indigo-600 transition duration-150">Back to Dashboard</button>
        </div>

    </main>

    <!-- 30-Minute Check-in Modal -->
    <div id="checkin-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50 hidden">
        <div class="bg-gray-800 p-8 rounded-xl shadow-2xl w-full max-w-md mx-4 transform transition-all duration-300 scale-100">
            <h2 class="text-2xl font-bold mb-4 text-indigo-400">Time to Check-In!</h2>
            <p class="text-lg text-gray-300 mb-6">What did you work on in the last 30 minutes?</p>
            <textarea id="checkin-input" rows="4" class="w-full p-3 border border-gray-600 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 resize-none bg-gray-700 text-white"></textarea>
            <button id="submit-checkin-btn" onclick="submitCheckin()" class="w-full mt-4 p-3 font-bold bg-green-600 text-white rounded-lg hover:bg-green-700 transition shadow-lg shadow-green-800/50">
                Submit Activity
            </button>
        </div>
    </div>

    <!-- General Confirmation Modal (Used for End Workday) -->
    <div id="confirmation-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-[60] hidden">
        <div class="bg-gray-800 p-6 rounded-xl shadow-2xl w-full max-w-sm mx-4">
            <h3 class="text-xl font-bold mb-4 text-red-400">Confirm Action</h3>
            <p id="confirmation-text" class="text-gray-300 mb-6">Are you sure you want to end your workday? This will reset your timer and tasks.</p>
            <div class="flex justify-end space-x-3">
                <button onclick="document.getElementById('confirmation-modal').classList.add('hidden')" class="px-4 py-2 border border-gray-600 rounded-lg text-gray-300 hover:bg-gray-700">Cancel</button>
                <button id="confirmation-action-btn" onclick="resetWorkday()" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition">Confirm</button>
            </div>
        </div>
    </div>


    <script type="module">
        // --- Firebase Initialization and Authentication ---

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let app, db, auth, userId = null;
        let unsubscribeTasks = () => {};
        let unsubscribeLogs = () => {};
        let isFirebaseReady = false; // New flag for Firebase status

        // Local state used when Firebase is unavailable (non-persistent)
        let localTasks = [];
        let localLogs = [];

        // Global state for the app
        let checkinInterval;
        let timerInterval;
        let workDurationMs = 0;
        let endTime = 0;
        const CHECKIN_DURATION_MS = 30 * 60 * 1000; // 30 minutes in milliseconds
        const dbCollectionTasks = 'workday_state';
        const dbCollectionLogs = 'checkin_logs';

        function getTaskDocRef() {
            if (!userId) return null;
            return firebase.doc(db, 'artifacts', appId, 'users', userId, dbCollectionTasks, 'current');
        }

        function getLogsCollectionRef() {
            if (!userId) return null;
            return firebase.collection(db, 'artifacts', appId, 'users', userId, dbCollectionLogs);
        }

        async function initFirebase() {
            // SAFETY CHECK: If the firebaseConfig object is empty, assume non-persistent mode.
            if (Object.keys(firebaseConfig).length === 0) {
                console.error("Firebase configuration is missing. Running in LOCAL (non-persistent) mode.");
                isFirebaseReady = false;
                // DO NOT call render functions here. Let the DOMContentLoaded handler handle the rendering.
                return;
            }
            
            try {
                // setLogLevel('Debug'); // Enable for debugging
                app = firebase.initializeApp(firebaseConfig);
                auth = firebase.getAuth(app);
                db = firebase.getFirestore(app);

                if (initialAuthToken) {
                    await firebase.signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await firebase.signInAnonymously(auth);
                }

                firebase.onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        isFirebaseReady = true; // Firebase is ready!
                        console.log("User authenticated. ID:", userId);
                        loadInitialWorkdayState();
                        setupRealtimeListeners();
                    } else {
                        console.error("Authentication failed. Running in LOCAL (non-persistent) mode.");
                        isFirebaseReady = false;
                        document.getElementById('setup-modal').classList.remove('hidden');
                    }
                });

            } catch (error) {
                console.error("Firebase initialization failed:", error);
                isFirebaseReady = false;
                document.getElementById('setup-modal').classList.remove('hidden');
            }
        }

        // --- Data Loading and State Management ---

        async function loadInitialWorkdayState() {
            const docRef = getTaskDocRef();
            if (!docRef || !isFirebaseReady) return;

            try {
                const docSnap = await firebase.getDoc(docRef);
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    const now = Date.now();
                    
                    if (data.endTime > now) {
                        // Workday is currently active
                        endTime = data.endTime;
                        document.getElementById('setup-modal').classList.add('hidden');
                        document.getElementById('dashboard-view').classList.remove('hidden');
                        document.getElementById('timer-display-container').classList.remove('hidden');
                        document.getElementById('toggle-log-btn').classList.remove('hidden');
                        startTimer();

                        // Set up next check-in time based on saved state, or immediately if overdue
                        setupNextCheckin(data.lastCheckinTime);
                        console.log("Resumed active workday.");

                    } else {
                        // Workday has ended or was reset
                        console.log("No active workday found or workday is over.");
                        document.getElementById('setup-modal').classList.remove('hidden');
                    }
                } else {
                     document.getElementById('setup-modal').classList.remove('hidden');
                }
            } catch (e) {
                console.error("Error loading workday state:", e);
                 document.getElementById('setup-modal').classList.remove('hidden');
            }
        }

        function setupRealtimeListeners() {
            if (!isFirebaseReady) return;

            // Task Listener (Reads from workday_state/current)
            const docRef = getTaskDocRef();
            if (docRef) {
                unsubscribeTasks = firebase.onSnapshot(docRef, (doc) => {
                    if (doc.exists()) {
                        const data = doc.data();
                        localTasks = data.tasks || []; // Sync local state
                        renderTasks(localTasks);
                        // Update local endTime if it changed (e.g., pause extension)
                        endTime = data.endTime;
                    } else {
                        localTasks = [];
                        renderTasks(localTasks); // Clear tasks if document is deleted
                    }
                }, (error) => {
                    console.error("Error listening to task data:", error);
                });
            }

            // Log Listener (Reads from checkin_logs)
            const logsRef = getLogsCollectionRef();
            if (logsRef) {
                const q = firebase.query(logsRef, firebase.orderBy('timestamp', 'desc'));
                unsubscribeLogs = firebase.onSnapshot(q, (snapshot) => {
                    const logs = [];
                    snapshot.forEach(doc => {
                        logs.push({ id: doc.id, ...doc.data() });
                    });
                    localLogs = logs; // Sync local state
                    renderLogEntries(localLogs);
                }, (error) => {
                    console.error("Error listening to log data:", error);
                });
            }
        }

        // --- Timer and Check-in Logic ---

        window.startWorkday = function() {
            const hours = parseInt(document.getElementById('work-hours').value);
            if (hours <= 0 || isNaN(hours)) {
                // Use a non-alert method for feedback
                const input = document.getElementById('work-hours');
                input.style.borderColor = 'red';
                setTimeout(() => input.style.borderColor = '', 2000);
                return;
            }

            workDurationMs = hours * 60 * 60 * 1000;
            endTime = Date.now() + workDurationMs;

            document.getElementById('setup-modal').classList.add('hidden');
            document.getElementById('dashboard-view').classList.remove('hidden');
            document.getElementById('timer-display-container').classList.remove('hidden');
            document.getElementById('toggle-log-btn').classList.remove('hidden');

            // Save initial state to Firestore IF ready
            if (isFirebaseReady) {
                const taskDocRef = getTaskDocRef();
                if (taskDocRef) {
                    firebase.setDoc(taskDocRef, {
                        endTime: endTime,
                        workDurationMs: workDurationMs,
                        lastCheckinTime: Date.now(),
                        tasks: localTasks, // Use the (empty) local array
                    }, { merge: true }).catch(e => console.error("Error setting initial workday state:", e));
                }
            }


            startTimer();
            setupNextCheckin(Date.now());
        }

        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);

            const updateTimer = () => {
                const remaining = endTime - Date.now();
                const timerDisplay = document.getElementById('timer-display');

                if (remaining <= 0) {
                    clearInterval(timerInterval);
                    timerDisplay.textContent = "00:00:00 - DONE!";
                    // Optional: Trigger end-of-workday action
                    return;
                }

                const totalSeconds = Math.floor(remaining / 1000);
                const h = String(Math.floor(totalSeconds / 3600)).padStart(2, '0');
                const m = String(Math.floor((totalSeconds % 3600) / 60)).padStart(2, '0');
                const s = String(totalSeconds % 60).padStart(2, '0');

                timerDisplay.textContent = `${h}:${m}:${s}`;
            };

            updateTimer(); // Initial call
            timerInterval = setInterval(updateTimer, 1000);
        }

        window.pauseTimer = async function(minutes) {
            if (endTime <= Date.now()) {
                // If workday is already over, restart from the last end time
                endTime = Date.now();
            }

            const extensionMs = minutes * 60 * 1000;
            endTime += extensionMs;
            startTimer(); // Restart to update the countdown immediately

            // Save new end time to Firestore IF ready
            if (isFirebaseReady) {
                const taskDocRef = getTaskDocRef();
                if (taskDocRef) {
                    await firebase.updateDoc(taskDocRef, {
                        endTime: endTime
                    }).catch(e => console.error("Error updating timer end time:", e));
                }
            }
        }

        function setupNextCheckin(lastCheckinTime) {
            if (checkinInterval) clearInterval(checkinInterval);

            const calculateNextCheckin = () => {
                const now = Date.now();
                const elapsedSinceLast = now - lastCheckinTime;
                
                // If it's been more than 30 mins, trigger immediately
                if (elapsedSinceLast >= CHECKIN_DURATION_MS) {
                    showCheckinModal();
                    lastCheckinTime = now; // Update locally after triggering
                }

                // Calculate time until next *full* 30-minute mark from now
                const timeToNextInterval = CHECKIN_DURATION_MS - (now % CHECKIN_DURATION_MS);
                
                // Set timeout for the next full 30-minute mark
                setTimeout(() => {
                    // This will execute at the next 30-minute mark (e.g., 12:30, 1:00)
                    showCheckinModal();
                    lastCheckinTime = Date.now();

                    // Then set up a recurring interval starting from this point
                    if (checkinInterval) clearInterval(checkinInterval);
                    checkinInterval = setInterval(() => {
                        showCheckinModal();
                        lastCheckinTime = Date.now();
                    }, CHECKIN_DURATION_MS);

                }, timeToNextInterval);
            }
            
            calculateNextCheckin();
        }

        function showCheckinModal() {
            // Only show if the dashboard is visible (i.e., workday is active)
            if (document.getElementById('dashboard-view').classList.contains('hidden')) return;

            document.getElementById('checkin-modal').classList.remove('hidden');
            document.getElementById('checkin-input').focus();
        }

        window.submitCheckin = async function() {
            const activity = document.getElementById('checkin-input').value.trim();
            if (!activity) {
                console.warn("Check-in activity cannot be empty.");
                document.getElementById('checkin-modal').classList.add('hidden');
                return;
            }

            const newLogEntry = {
                id: Date.now().toString(), // local ID
                activity: activity,
                timestamp: { toDate: () => new Date() } // Mock Date object for local rendering
            };
            
            // Update local state and render
            localLogs.unshift(newLogEntry);
            renderLogEntries(localLogs);

            // Save to Firestore IF ready
            if (isFirebaseReady) {
                const logsRef = getLogsCollectionRef();
                const taskDocRef = getTaskDocRef();
                if (logsRef && taskDocRef) {
                    await firebase.addDoc(logsRef, {
                        timestamp: firebase.serverTimestamp(),
                        activity: activity
                    }).catch(e => console.error("Error saving check-in log:", e));

                    await firebase.updateDoc(taskDocRef, {
                        lastCheckinTime: Date.now()
                    }).catch(e => console.error("Error updating last check-in time:", e));
                }
            }


            document.getElementById('checkin-input').value = '';
            document.getElementById('checkin-modal').classList.add('hidden');
        }

        window.confirmReset = function() {
            document.getElementById('confirmation-modal').classList.remove('hidden');
        }

        window.resetWorkday = function() {
            clearInterval(timerInterval);
            clearInterval(checkinInterval);
            
            if (isFirebaseReady) {
                unsubscribeTasks();
                unsubscribeLogs();

                // Clear state document (or mark as ended)
                const docRef = getTaskDocRef();
                if (docRef) {
                    firebase.deleteDoc(docRef).catch(e => console.error("Error deleting workday state:", e));
                }
            }

            // Clear local state
            localTasks = [];
            localLogs = [];
            renderTasks(localTasks);
            renderLogEntries(localLogs);

            // Reset UI
            document.getElementById('timer-display').textContent = '00:00:00';
            document.getElementById('timer-display-container').classList.add('hidden');
            document.getElementById('toggle-log-btn').classList.add('hidden');
            document.getElementById('dashboard-view').classList.add('hidden');
            document.getElementById('log-view').classList.add('hidden');
            document.getElementById('setup-modal').classList.remove('hidden');
            document.getElementById('confirmation-modal').classList.add('hidden');

            console.log("Workday reset.");
        }


        // --- Task Management ---

        function renderTasks(tasks) {
            const list = document.getElementById('task-list');
            const emptyState = document.getElementById('tasks-empty-state');
            
            // Safety check for critical elements (must exist before proceeding)
            if (!list || !emptyState) {
                console.error("Task list elements not found in the DOM.");
                return;
            }

            list.innerHTML = '';
            
            if (tasks.length === 0) {
                emptyState.classList.remove('hidden');
                return;
            } else {
                emptyState.classList.add('hidden');
            }

            // 1. Sort: Uncompleted tasks first, then completed tasks (which shift to the bottom)
            tasks.sort((a, b) => {
                if (a.completed !== b.completed) {
                    return a.completed ? 1 : -1;
                }
                // Secondary sort: by creation time (newest first for incomplete, or original order for complete)
                return a.timestamp - b.timestamp;
            });

            tasks.forEach((task, index) => {
                const isCompleted = task.completed;
                const li = document.createElement('li');
                
                // Dark Mode Class Update:
                // Incomplete: bg-gray-800, text-gray-100, hover:bg-gray-700
                // Completed: bg-green-900/50, text-gray-400
                li.className = `flex items-center p-3 rounded-lg shadow-sm border border-gray-700 transition duration-150 ${isCompleted 
                    ? 'bg-green-900/50 text-gray-400' 
                    : 'bg-gray-800 text-gray-100 hover:bg-gray-700'}`;
                
                li.innerHTML = `
                    <input type="checkbox" id="task-${index}" ${isCompleted ? 'checked' : ''} onchange="toggleTask(${index})" 
                           class="w-5 h-5 text-indigo-500 border-gray-600 rounded focus:ring-indigo-500 mr-4 cursor-pointer bg-gray-700">
                    <label for="task-${index}" class="flex-grow text-base ${isCompleted ? 'line-through' : ''} cursor-pointer">
                        ${task.text}
                    </label>
                    <button onclick="deleteTask(${index})" class="text-gray-500 hover:text-red-500 ml-4 p-1 rounded-full opacity-0 log-entry transition-opacity delete-btn">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3"></path></svg>
                    </button>
                `;
                list.appendChild(li);
            });
        }

        window.addTask = async function() {
            const input = document.getElementById('new-task-input');
            const text = input.value.trim();

            if (!text) return;

            const newTask = {
                text: text,
                completed: false,
                timestamp: Date.now() 
            };
            
            // Add locally
            localTasks.push(newTask);
            renderTasks(localTasks);
            input.value = '';

            // Save to Firestore IF ready
            if (isFirebaseReady) {
                const docRef = getTaskDocRef();
                if (docRef) {
                    await updateTaskArrayInFirestore(localTasks);
                }
            }
        }

        async function updateTaskArrayInFirestore(tasks) {
             const docRef = getTaskDocRef();
             if (docRef) {
                 await firebase.updateDoc(docRef, { tasks: tasks })
                     .catch(e => console.error("Error updating tasks array:", e));
             }
        }

        window.toggleTask = function(index) {
            if (localTasks[index]) {
                localTasks[index].completed = !localTasks[index].completed;
                renderTasks(localTasks);
                
                if (isFirebaseReady) {
                    updateTaskArrayInFirestore(localTasks);
                }
            }
        }

        window.deleteTask = function(index) {
             localTasks.splice(index, 1);
             renderTasks(localTasks);

             if (isFirebaseReady) {
                 updateTaskArrayInFirestore(localTasks);
             }
        }


        // --- Activity Log Management ---

        function renderLogEntries(logs) {
            const container = document.getElementById('log-entries-container');
            const emptyState = document.getElementById('log-empty-state');

            // Safety check for critical elements (must exist before proceeding)
            if (!container || !emptyState) {
                console.error("Log entry elements not found in the DOM.");
                return;
            }

            container.innerHTML = ''; // Clear existing

            if (logs.length === 0) {
                emptyState.classList.remove('hidden');
                return;
            } else {
                emptyState.classList.add('hidden');
            }

            logs.forEach(log => {
                // Check if timestamp is a mock object (local) or a Firestore Timestamp
                const date = log.timestamp && log.timestamp.toDate ? log.timestamp.toDate() : new Date();
                const timeString = date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });

                const div = document.createElement('div');
                // Dark Mode Class Update: bg-gray-800, text-gray-100, border-indigo-500
                div.className = 'log-entry bg-gray-800 p-4 rounded-lg shadow-md border-l-4 border-indigo-500 relative flex justify-between items-start';
                
                // Only show delete button if Firebase is ready and the log entry has an ID (i.e. is persisted or has a local ID)
                const deleteButton = isFirebaseReady || log.id 
                    ? `<button onclick="deleteLog('${log.id}')" class="delete-btn text-gray-500 hover:text-red-500 ml-4 p-1 rounded-full opacity-0 transition-opacity">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3"></path></svg>
                        </button>`
                    : '';

                div.innerHTML = `
                    <div>
                        <p class="text-sm font-semibold text-indigo-400 mb-1">${timeString} Check-in:</p>
                        <p class="text-gray-100 whitespace-pre-wrap">${log.activity}</p>
                    </div>
                    ${deleteButton}
                `;
                container.appendChild(div);
            });
        }

        window.deleteLog = async function(logId) {
            // Delete locally
            localLogs = localLogs.filter(log => log.id !== logId);
            renderLogEntries(localLogs);

            // Delete from Firestore IF ready
            if (isFirebaseReady) {
                const logsRef = getLogsCollectionRef();
                if (logsRef) {
                    const docRef = firebase.doc(logsRef, logId);
                    await firebase.deleteDoc(docRef).catch(e => console.error("Error deleting log entry:", e));
                }
            }
        }


        // --- View Toggling ---

        window.toggleView = function() {
            const dashboard = document.getElementById('dashboard-view');
            const log = document.getElementById('log-view');
            const btn = document.getElementById('toggle-log-btn');

            if (dashboard.classList.contains('hidden')) {
                // Currently on Log View, switch to Dashboard
                dashboard.classList.remove('hidden');
                log.classList.add('hidden');
                btn.textContent = 'View Log';
            } else {
                // Currently on Dashboard View, switch to Log
                dashboard.classList.add('hidden');
                log.classList.remove('hidden');
                btn.textContent = 'Back to Work';
            }
        }

        // --- Global Load Handler ---
        window.onload = function() {
            // 1. Initialize Firebase (or fall back to local mode)
            initFirebase(); 

            // 2. Regardless of Firebase status, ensure the initial UI rendering happens now that the DOM is ready.
            renderTasks(localTasks);
            renderLogEntries(localLogs);

            // 3. Show the setup modal if Firebase is not ready OR if Firebase is ready but no session was loaded
            if (!isFirebaseReady || document.getElementById('dashboard-view').classList.contains('hidden')) {
                document.getElementById('setup-modal').classList.remove('hidden');
            }
        };
    </script>

</body>
</html>
