<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WFM Productivity Dashboard</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght=100..900&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #f7f9fb; }
        /* Custom scrollbar for better look */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #e2e8f0; }
        ::-webkit-scrollbar-thumb { background: #94a3b8; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }
        .log-entry:hover .delete-btn { opacity: 1; }
    </style>
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, orderBy, addDoc, serverTimestamp, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global Firebase variables for easy access in the main script
        window.firebase = {
            initializeApp, getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged,
            getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, orderBy, addDoc, serverTimestamp, getDocs, setLogLevel
        };
    </script>
</head>
<body class="min-h-screen flex flex-col antialiased">

    <!-- Header: Timer & Controls (Fixed Top Right) -->
    <header id="header" class="fixed top-0 right-0 p-4 z-40 w-full sm:w-auto transition-all duration-300">
        <div id="timer-display-container" class="hidden bg-white shadow-xl rounded-lg p-3 flex items-center space-x-3 border border-indigo-100">
            <span class="text-xs font-semibold text-indigo-500 uppercase">Remaining:</span>
            <span id="timer-display" class="text-3xl font-bold text-indigo-700">00:00:00</span>
        </div>
        <button id="toggle-log-btn" onclick="toggleView()" class="hidden mt-2 px-3 py-1 bg-indigo-500 text-white text-sm font-medium rounded-full shadow-md hover:bg-indigo-600 transition duration-150">View Log</button>
    </header>

    <!-- Main Content Area -->
    <main class="flex-grow p-4 sm:p-8 pt-20">

        <!-- Initial Setup Modal (Large Button Pop-up) -->
        <div id="setup-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50">
            <div class="bg-white p-8 rounded-xl shadow-2xl w-full max-w-lg mx-4">
                <h2 class="text-2xl font-bold mb-6 text-indigo-700">Start Your Workday</h2>
                <div class="mb-6">
                    <label for="work-hours" class="block text-sm font-medium text-gray-700 mb-2">How many hours will you be working today?</label>
                    <input type="number" id="work-hours" min="1" max="12" value="8" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 text-lg">
                </div>
                <button id="start-work-btn" onclick="startWorkday()" class="w-full p-4 text-xl font-bold bg-indigo-600 text-white rounded-xl hover:bg-indigo-700 transition shadow-lg shadow-indigo-200">
                    START WORK DAY
                </button>
            </div>
        </div>

        <!-- Task Dashboard View -->
        <div id="dashboard-view" class="max-w-4xl mx-auto space-y-8 hidden">
            <!-- Workday Controls -->
            <section class="bg-white p-6 rounded-xl shadow-lg border border-gray-100">
                <h3 class="text-xl font-semibold text-gray-800 mb-4">Timer Controls</h3>
                <div class="flex flex-wrap gap-3">
                    <button onclick="pauseTimer(15)" class="px-4 py-2 bg-yellow-100 text-yellow-700 rounded-lg font-medium hover:bg-yellow-200 transition">Pause +15 mins</button>
                    <button onclick="pauseTimer(30)" class="px-4 py-2 bg-yellow-100 text-yellow-700 rounded-lg font-medium hover:bg-yellow-200 transition">Pause +30 mins</button>
                    <button onclick="pauseTimer(60)" class="px-4 py-2 bg-yellow-100 text-yellow-700 rounded-lg font-medium hover:bg-yellow-200 transition">Pause +1 hour</button>
                    <button id="reset-work-btn" onclick="confirmReset()" class="px-4 py-2 bg-red-100 text-red-700 rounded-lg font-medium hover:bg-red-200 transition">End Workday</button>
                </div>
            </section>

            <!-- Task Input -->
            <section class="bg-white p-6 rounded-xl shadow-lg border border-gray-100">
                <h3 class="text-xl font-semibold text-gray-800 mb-4">What would you like to accomplish today?</h3>
                <div class="flex space-x-3">
                    <input type="text" id="new-task-input" placeholder="Enter a new task..." class="flex-grow p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500">
                    <button onclick="addTask()" class="px-6 py-3 bg-indigo-600 text-white rounded-lg font-bold hover:bg-indigo-700 transition shadow-md">Add</button>
                </div>
            </section>

            <!-- Task List -->
            <section class="bg-white p-6 rounded-xl shadow-lg border border-gray-100 min-h-[200px]">
                <h3 class="text-xl font-semibold text-gray-800 mb-4">To Do List</h3>
                <ul id="task-list" class="space-y-3">
                    <!-- Tasks will be injected here -->
                    <p id="tasks-empty-state" class="text-gray-500 italic">No tasks yet. Add one above!</p>
                </ul>
            </section>
        </div>

        <!-- Activity Log View -->
        <div id="log-view" class="max-w-4xl mx-auto space-y-8 hidden">
            <h2 class="text-3xl font-bold text-indigo-700">Workday Activity Log</h2>
            <p class="text-gray-600">Review your 30-minute check-ins throughout the day.</p>
            <div id="log-entries-container" class="space-y-4">
                <!-- Log entries will be injected here -->
                <p id="log-empty-state" class="text-gray-500 italic p-4 bg-white rounded-lg shadow">No check-in entries yet.</p>
            </div>
            <button onclick="toggleView()" class="px-4 py-2 bg-indigo-500 text-white rounded-lg font-medium hover:bg-indigo-600 transition duration-150">Back to Dashboard</button>
        </div>

    </main>

    <!-- 30-Minute Check-in Modal -->
    <div id="checkin-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50 hidden">
        <div class="bg-white p-8 rounded-xl shadow-2xl w-full max-w-md mx-4 transform transition-all duration-300 scale-100">
            <h2 class="text-2xl font-bold mb-4 text-indigo-700">Time to Check-In!</h2>
            <p class="text-lg text-gray-700 mb-6">What did you work on in the last 30 minutes?</p>
            <textarea id="checkin-input" rows="4" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 resize-none"></textarea>
            <button id="submit-checkin-btn" onclick="submitCheckin()" class="w-full mt-4 p-3 font-bold bg-green-600 text-white rounded-lg hover:bg-green-700 transition shadow-lg shadow-green-200">
                Submit Activity
            </button>
        </div>
    </div>

    <!-- General Confirmation Modal (Used for End Workday) -->
    <div id="confirmation-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-[60] hidden">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-sm mx-4">
            <h3 class="text-xl font-bold mb-4 text-red-600">Confirm Action</h3>
            <p id="confirmation-text" class="text-gray-700 mb-6">Are you sure you want to end your workday? This will reset your timer and tasks.</p>
            <div class="flex justify-end space-x-3">
                <button onclick="document.getElementById('confirmation-modal').classList.add('hidden')" class="px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-100">Cancel</button>
                <button id="confirmation-action-btn" onclick="resetWorkday()" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition">Confirm</button>
            </div>
        </div>
    </div>


    <script type="module">
        // --- Firebase Initialization and Authentication ---

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let app, db, auth, userId = null;
        let unsubscribeTasks = () => {};
        let unsubscribeLogs = () => {};

        // Global state for the app
        let checkinInterval;
        let timerInterval;
        let workDurationMs = 0;
        let endTime = 0;
        const CHECKIN_DURATION_MS = 30 * 60 * 1000; // 30 minutes in milliseconds
        const dbCollectionTasks = 'workday_state';
        const dbCollectionLogs = 'checkin_logs';

        function getTaskDocRef() {
            if (!userId) return null;
            return firebase.doc(db, 'artifacts', appId, 'users', userId, dbCollectionTasks, 'current');
        }

        function getLogsCollectionRef() {
            if (!userId) return null;
            return firebase.collection(db, 'artifacts', appId, 'users', userId, dbCollectionLogs);
        }

        async function initFirebase() {
            // SAFETY CHECK: Ensure the firebaseConfig object is not empty before trying to initialize.
            if (Object.keys(firebaseConfig).length === 0) {
                console.error("Firebase configuration is missing. Cannot connect to database for persistence.");
                return; 
            }
            
            try {
                // setLogLevel('Debug'); // Enable for debugging
                app = firebase.initializeApp(firebaseConfig);
                auth = firebase.getAuth(app);
                db = firebase.getFirestore(app);

                if (initialAuthToken) {
                    await firebase.signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await firebase.signInAnonymously(auth);
                }

                firebase.onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log("User authenticated. ID:", userId);
                        loadInitialWorkdayState();
                        setupRealtimeListeners();
                    } else {
                        console.error("Authentication failed.");
                    }
                });

            } catch (error) {
                console.error("Firebase initialization failed:", error);
            }
        }

        // --- Data Loading and State Management ---

        async function loadInitialWorkdayState() {
            const docRef = getTaskDocRef();
            if (!docRef) return;

            try {
                const docSnap = await firebase.getDoc(docRef);
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    const now = Date.now();
                    
                    if (data.endTime > now) {
                        // Workday is currently active
                        endTime = data.endTime;
                        document.getElementById('setup-modal').classList.add('hidden');
                        document.getElementById('dashboard-view').classList.remove('hidden');
                        document.getElementById('timer-display-container').classList.remove('hidden');
                        document.getElementById('toggle-log-btn').classList.remove('hidden');
                        startTimer();

                        // Set up next check-in time based on saved state, or immediately if overdue
                        setupNextCheckin(data.lastCheckinTime);
                        console.log("Resumed active workday.");

                    } else {
                        // Workday has ended or was reset
                        console.log("No active workday found or workday is over.");
                    }
                }
            } catch (e) {
                console.error("Error loading workday state:", e);
            }
        }

        function setupRealtimeListeners() {
            // Task Listener (Reads from workday_state/current)
            const docRef = getTaskDocRef();
            if (docRef) {
                unsubscribeTasks = firebase.onSnapshot(docRef, (doc) => {
                    if (doc.exists()) {
                        const data = doc.data();
                        renderTasks(data.tasks || []);
                        // Update local endTime if it changed (e.g., pause extension)
                        endTime = data.endTime;
                    } else {
                        renderTasks([]); // Clear tasks if document is deleted
                    }
                }, (error) => {
                    console.error("Error listening to task data:", error);
                });
            }

            // Log Listener (Reads from checkin_logs)
            const logsRef = getLogsCollectionRef();
            if (logsRef) {
                const q = firebase.query(logsRef, firebase.orderBy('timestamp', 'desc'));
                unsubscribeLogs = firebase.onSnapshot(q, (snapshot) => {
                    const logs = [];
                    snapshot.forEach(doc => {
                        logs.push({ id: doc.id, ...doc.data() });
                    });
                    renderLogEntries(logs);
                }, (error) => {
                    console.error("Error listening to log data:", error);
                });
            }
        }

        // --- Timer and Check-in Logic ---

        window.startWorkday = function() {
            const hours = parseInt(document.getElementById('work-hours').value);
            if (hours <= 0 || isNaN(hours)) {
                alert("Please enter a valid number of hours.");
                return;
            }

            workDurationMs = hours * 60 * 60 * 1000;
            endTime = Date.now() + workDurationMs;

            document.getElementById('setup-modal').classList.add('hidden');
            document.getElementById('dashboard-view').classList.remove('hidden');
            document.getElementById('timer-display-container').classList.remove('hidden');
            document.getElementById('toggle-log-btn').classList.remove('hidden');

            // Save initial state to Firestore
            const taskDocRef = getTaskDocRef();
            if (taskDocRef) {
                firebase.setDoc(taskDocRef, {
                    endTime: endTime,
                    workDurationMs: workDurationMs,
                    lastCheckinTime: Date.now(),
                    tasks: [],
                }, { merge: true }).catch(e => console.error("Error setting initial workday state:", e));
            }

            startTimer();
            setupNextCheckin(Date.now());
        }

        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);

            const updateTimer = () => {
                const remaining = endTime - Date.now();
                const timerDisplay = document.getElementById('timer-display');

                if (remaining <= 0) {
                    clearInterval(timerInterval);
                    timerDisplay.textContent = "00:00:00 - DONE!";
                    // Optional: Trigger end-of-workday action
                    return;
                }

                const totalSeconds = Math.floor(remaining / 1000);
                const h = String(Math.floor(totalSeconds / 3600)).padStart(2, '0');
                const m = String(Math.floor((totalSeconds % 3600) / 60)).padStart(2, '0');
                const s = String(totalSeconds % 60).padStart(2, '0');

                timerDisplay.textContent = `${h}:${m}:${s}`;
            };

            updateTimer(); // Initial call
            timerInterval = setInterval(updateTimer, 1000);
        }

        window.pauseTimer = async function(minutes) {
            if (endTime <= Date.now()) {
                // If workday is already over, restart from the last end time
                endTime = Date.now();
            }

            const extensionMs = minutes * 60 * 1000;
            endTime += extensionMs;
            startTimer(); // Restart to update the countdown immediately

            // Save new end time to Firestore
            const taskDocRef = getTaskDocRef();
            if (taskDocRef) {
                await firebase.updateDoc(taskDocRef, {
                    endTime: endTime
                }).catch(e => console.error("Error updating timer end time:", e));
            }
        }

        function setupNextCheckin(lastCheckinTime) {
            if (checkinInterval) clearInterval(checkinInterval);

            const calculateNextCheckin = () => {
                const now = Date.now();
                const elapsedSinceLast = now - lastCheckinTime;
                
                // If it's been more than 30 mins, trigger immediately
                if (elapsedSinceLast >= CHECKIN_DURATION_MS) {
                    showCheckinModal();
                    lastCheckinTime = now; // Update locally after triggering
                }

                // Calculate time until next *full* 30-minute mark from now
                const timeToNextInterval = CHECKIN_DURATION_MS - (now % CHECKIN_DURATION_MS);
                
                // Set timeout for the next full 30-minute mark
                setTimeout(() => {
                    // This will execute at the next 30-minute mark (e.g., 12:30, 1:00)
                    showCheckinModal();
                    lastCheckinTime = Date.now();

                    // Then set up a recurring interval starting from this point
                    if (checkinInterval) clearInterval(checkinInterval);
                    checkinInterval = setInterval(() => {
                        showCheckinModal();
                        lastCheckinTime = Date.now();
                    }, CHECKIN_DURATION_MS);

                }, timeToNextInterval);
            }
            
            calculateNextCheckin();
        }

        function showCheckinModal() {
            // Only show if the dashboard is visible (i.e., workday is active)
            if (document.getElementById('dashboard-view').classList.contains('hidden')) return;

            document.getElementById('checkin-modal').classList.remove('hidden');
            document.getElementById('checkin-input').focus();
        }

        window.submitCheckin = async function() {
            const activity = document.getElementById('checkin-input').value.trim();
            if (!activity) {
                // Use custom message box instead of alert
                console.warn("Check-in activity cannot be empty.");
                document.getElementById('checkin-modal').classList.add('hidden');
                return;
            }

            const logsRef = getLogsCollectionRef();
            if (logsRef) {
                await firebase.addDoc(logsRef, {
                    timestamp: firebase.serverTimestamp(),
                    activity: activity
                }).catch(e => console.error("Error saving check-in log:", e));

                // Update the last check-in time in the state document
                const taskDocRef = getTaskDocRef();
                if (taskDocRef) {
                     await firebase.updateDoc(taskDocRef, {
                        lastCheckinTime: Date.now()
                    }).catch(e => console.error("Error updating last check-in time:", e));
                }

                document.getElementById('checkin-input').value = '';
                document.getElementById('checkin-modal').classList.add('hidden');
            }
        }

        window.confirmReset = function() {
            document.getElementById('confirmation-modal').classList.remove('hidden');
        }

        window.resetWorkday = function() {
            clearInterval(timerInterval);
            clearInterval(checkinInterval);
            unsubscribeTasks();
            unsubscribeLogs();

            // Clear state document (or mark as ended)
            const docRef = getTaskDocRef();
            if (docRef) {
                firebase.deleteDoc(docRef).catch(e => console.error("Error deleting workday state:", e));
            }

            // Reset UI
            document.getElementById('timer-display').textContent = '00:00:00';
            document.getElementById('timer-display-container').classList.add('hidden');
            document.getElementById('toggle-log-btn').classList.add('hidden');
            document.getElementById('dashboard-view').classList.add('hidden');
            document.getElementById('log-view').classList.add('hidden');
            document.getElementById('setup-modal').classList.remove('hidden');
            document.getElementById('confirmation-modal').classList.add('hidden');

            console.log("Workday reset.");
        }


        // --- Task Management ---

        function renderTasks(tasks) {
            const list = document.getElementById('task-list');
            const emptyState = document.getElementById('tasks-empty-state');
            
            // Safety check for critical elements
            if (!list || !emptyState) {
                console.error("Task list elements not found in the DOM.");
                return;
            }

            list.innerHTML = '';
            
            if (tasks.length === 0) {
                emptyState.classList.remove('hidden');
                return;
            } else {
                emptyState.classList.add('hidden');
            }

            // 1. Sort: Uncompleted tasks first, then completed tasks (which shift to the bottom)
            tasks.sort((a, b) => {
                if (a.completed !== b.completed) {
                    return a.completed ? 1 : -1;
                }
                // Secondary sort: by creation time (newest first for incomplete, or original order for complete)
                return a.timestamp - b.timestamp;
            });

            tasks.forEach((task, index) => {
                const li = document.createElement('li');
                li.className = `flex items-center p-3 rounded-lg shadow-sm border border-gray-100 transition duration-150 ${task.completed ? 'bg-green-50/50 text-gray-500' : 'bg-white text-gray-800 hover:bg-gray-50'}`;
                li.innerHTML = `
                    <input type="checkbox" id="task-${index}" ${task.completed ? 'checked' : ''} onchange="toggleTask(${index})" 
                           class="w-5 h-5 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500 mr-4 cursor-pointer">
                    <label for="task-${index}" class="flex-grow text-base ${task.completed ? 'line-through' : ''} cursor-pointer">
                        ${task.text}
                    </label>
                    <button onclick="deleteTask(${index})" class="text-gray-400 hover:text-red-600 ml-4 p-1 rounded-full opacity-0 log-entry transition-opacity delete-btn">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3"></path></svg>
                    </button>
                `;
                list.appendChild(li);
            });
        }

        window.addTask = async function() {
            const input = document.getElementById('new-task-input');
            const text = input.value.trim();

            if (!text) return;

            const docRef = getTaskDocRef();
            if (docRef) {
                const docSnap = await firebase.getDoc(docRef);
                const currentTasks = docSnap.exists() ? (docSnap.data().tasks || []) : [];

                const newTask = {
                    text: text,
                    completed: false,
                    timestamp: Date.now() // Use timestamp for sorting/identification
                };

                currentTasks.push(newTask);

                await firebase.updateDoc(docRef, { tasks: currentTasks })
                    .then(() => input.value = '')
                    .catch(e => console.error("Error adding task:", e));
            }
        }

        async function updateTaskArray(callback) {
            const docRef = getTaskDocRef();
            if (docRef) {
                const docSnap = await firebase.getDoc(docRef);
                if (docSnap.exists()) {
                    let tasks = docSnap.data().tasks || [];
                    tasks = callback(tasks);
                    await firebase.updateDoc(docRef, { tasks: tasks })
                        .catch(e => console.error("Error updating tasks array:", e));
                }
            }
        }

        window.toggleTask = function(index) {
            updateTaskArray((tasks) => {
                if (tasks[index]) {
                    tasks[index].completed = !tasks[index].completed;
                }
                return tasks;
            });
        }

        window.deleteTask = function(index) {
             updateTaskArray((tasks) => {
                tasks.splice(index, 1);
                return tasks;
            });
        }


        // --- Activity Log Management ---

        function renderLogEntries(logs) {
            const container = document.getElementById('log-entries-container');
            const emptyState = document.getElementById('log-empty-state');

            // Safety check for critical elements
            if (!container || !emptyState) {
                console.error("Log entry elements not found in the DOM.");
                return;
            }

            container.innerHTML = ''; // Clear existing

            if (logs.length === 0) {
                emptyState.classList.remove('hidden');
                return;
            } else {
                emptyState.classList.add('hidden');
            }

            logs.forEach(log => {
                const date = log.timestamp ? log.timestamp.toDate() : new Date();
                const timeString = date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });

                const div = document.createElement('div');
                div.className = 'log-entry bg-white p-4 rounded-lg shadow-md border-l-4 border-indigo-500 relative flex justify-between items-start';
                div.innerHTML = `
                    <div>
                        <p class="text-sm font-semibold text-indigo-700 mb-1">${timeString} Check-in:</p>
                        <p class="text-gray-800 whitespace-pre-wrap">${log.activity}</p>
                    </div>
                    <button onclick="deleteLog('${log.id}')" class="delete-btn text-gray-400 hover:text-red-600 ml-4 p-1 rounded-full opacity-0 transition-opacity">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3"></path></svg>
                    </button>
                `;
                container.appendChild(div);
            });
        }

        window.deleteLog = async function(logId) {
            const logsRef = getLogsCollectionRef();
            if (logsRef) {
                const docRef = firebase.doc(logsRef, logId);
                await firebase.deleteDoc(docRef).catch(e => console.error("Error deleting log entry:", e));
            }
        }


        // --- View Toggling ---

        window.toggleView = function() {
            const dashboard = document.getElementById('dashboard-view');
            const log = document.getElementById('log-view');
            const btn = document.getElementById('toggle-log-btn');

            if (dashboard.classList.contains('hidden')) {
                // Currently on Log View, switch to Dashboard
                dashboard.classList.remove('hidden');
                log.classList.add('hidden');
                btn.textContent = 'View Log';
            } else {
                // Currently on Dashboard View, switch to Log
                dashboard.classList.add('hidden');
                log.classList.remove('hidden');
                btn.textContent = 'Back to Work';
            }
        }

        // Initialize everything
        window.onload = initFirebase;
    </script>

</body>
</html>
